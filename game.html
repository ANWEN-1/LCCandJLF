<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>äº”å­æ£‹å¯¹æˆ˜</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            color: #333;
        }

        h1 {
            margin: 10px 0;
            font-size: 28px;
            color: #333;
        }

        /* === æ£‹ç›˜åŒºåŸŸ === */
        .game-wrapper {
            position: relative;
            padding: 15px;
            background: #e0c39e;
            /* æœ¨å¤´é¢œè‰² */
            border-radius: 5px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            border: 5px solid #8b5a2b;
        }

        canvas {
            display: block;
            cursor: pointer;
            background-color: #eabc80;
            /* æ£‹ç›˜åº•è‰² */
        }

        /* === æ§åˆ¶é¢æ¿ === */
        .status-bar {
            margin-top: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            background: white;
            padding: 10px 20px;
            border-radius: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .turn-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
            font-size: 18px;
        }

        .stone-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #999;
        }

        .black-stone {
            background: black;
        }

        .white-stone {
            background: white;
        }

        .btn {
            padding: 8px 20px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
            color: white;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn-undo {
            background-color: #f39c12;
        }

        .btn-restart {
            background-color: #27ae60;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            text-decoration: none;
            color: #555;
            font-weight: bold;
            background: white;
            padding: 5px 15px;
            border-radius: 20px;
        }

        /* === é»‘å¤œæ¨¡å¼é€‚é… === */
        body.dark-mode {
            background-color: #1a2340;
        }

        body.dark-mode h1 {
            color: white;
        }

        body.dark-mode .status-bar {
            background: #2b324d;
            color: white;
        }

        body.dark-mode .back-link {
            background: #333;
            color: white;
        }
    </style>
</head>

<body>

    <a href="index.html" class="back-link">â† è¿”å›ä¸»é¡µ</a>
    <h1>âš« äº”å­æ£‹å¯¹æˆ˜ âšª</h1>

    <div class="game-wrapper">
        <canvas id="board" width="450" height="450"></canvas>
    </div>

    <div class="status-bar">
        <div class="turn-indicator">
            å½“å‰å›åˆ:
            <div id="current-stone" class="stone-icon black-stone"></div>
            <span id="player-text">é»‘æ–¹</span>
        </div>
        <button class="btn btn-undo" onclick="undo()">æ‚”æ£‹</button>
        <button class="btn btn-restart" onclick="restart()">é‡æ¥</button>
    </div>

    <script src="assets/js/theme.js"></script>

    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const turnIcon = document.getElementById('current-stone');
        const playerText = document.getElementById('player-text');

        // === æ¸¸æˆé…ç½® ===
        const GRID_SIZE = 15; // 15x15 æ£‹ç›˜
        const CELL_SIZE = 30; // æ¯ä¸ªæ ¼å­ 30px
        const PADDING = 15;   // è¾¹ç¼˜ç•™ç™½

        // çŠ¶æ€å˜é‡
        let board = []; // 0:ç©º, 1:é»‘, 2:ç™½
        let currentPlayer = 1; // 1:é»‘å…ˆ
        let history = []; // è®°å½•æ¯ä¸€æ­¥ï¼Œç”¨äºæ‚”æ£‹
        let isGameOver = false;

        // åˆå§‹åŒ–
        function init() {
            // æ¸…ç©ºæ£‹ç›˜æ•°ç»„
            board = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
            currentPlayer = 1;
            history = [];
            isGameOver = false;
            updateUI();
            drawBoard();
        }

        // 1. ç»˜åˆ¶æ£‹ç›˜çº¿
        function drawBoard() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.beginPath();
            ctx.strokeStyle = "#555";
            ctx.lineWidth = 1;

            for (let i = 0; i < GRID_SIZE; i++) {
                // æ¨ªçº¿
                ctx.moveTo(PADDING + i * CELL_SIZE, PADDING);
                ctx.lineTo(PADDING + i * CELL_SIZE, PADDING + (GRID_SIZE - 1) * CELL_SIZE);
                // ç«–çº¿
                ctx.moveTo(PADDING, PADDING + i * CELL_SIZE);
                ctx.lineTo(PADDING + (GRID_SIZE - 1) * CELL_SIZE, PADDING + i * CELL_SIZE);
            }
            ctx.stroke();

            // ç”»å¤©å…ƒå’Œæ˜Ÿä½ (ä¸­é—´çš„å°é»‘ç‚¹)
            drawDot(7, 7); // å¤©å…ƒ
            drawDot(3, 3); drawDot(3, 11);
            drawDot(11, 3); drawDot(11, 11);

            // é‡æ–°ç”»æ‰€æœ‰æ£‹å­
            for (let i = 0; i < history.length; i++) {
                let step = history[i];
                drawPiece(step.x, step.y, step.role, i === history.length - 1);
            }
        }

        // ç”»æ˜Ÿä½å°ç‚¹
        function drawDot(x, y) {
            ctx.beginPath();
            ctx.arc(PADDING + x * CELL_SIZE, PADDING + y * CELL_SIZE, 3, 0, Math.PI * 2);
            ctx.fillStyle = "black";
            ctx.fill();
        }

        // 2. ç»˜åˆ¶æ£‹å­
        function drawPiece(x, y, role, isLast) {
            const centerX = PADDING + x * CELL_SIZE;
            const centerY = PADDING + y * CELL_SIZE;

            ctx.beginPath();
            ctx.arc(centerX, centerY, 13, 0, Math.PI * 2);

            // æ£‹å­æ¸å˜è‰²ï¼Œçœ‹èµ·æ¥æ›´æœ‰ç«‹ä½“æ„Ÿ
            const gradient = ctx.createRadialGradient(centerX - 3, centerY - 3, 2, centerX, centerY, 13);
            if (role === 1) { // é»‘æ£‹
                gradient.addColorStop(0, "#555");
                gradient.addColorStop(1, "black");
            } else { // ç™½æ£‹
                gradient.addColorStop(0, "white");
                gradient.addColorStop(1, "#ddd");
            }
            ctx.fillStyle = gradient;
            ctx.fill();

            // å¦‚æœæ˜¯æœ€åä¸€æ­¥ï¼Œç”»ä¸ªçº¢è‰²æ ‡è®°
            if (isLast) {
                ctx.beginPath();
                ctx.moveTo(centerX - 5, centerY);
                ctx.lineTo(centerX + 5, centerY);
                ctx.moveTo(centerX, centerY - 5);
                ctx.lineTo(centerX, centerY + 5);
                ctx.strokeStyle = "red";
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // 3. ç‚¹å‡»è½å­
        canvas.addEventListener('mousedown', (e) => {
            if (isGameOver) return;

            // è·å–ç‚¹å‡»åæ ‡
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // è®¡ç®—æœ€è¿‘çš„äº¤å‰ç‚¹
            // Math.round å››èˆäº”å…¥ï¼Œç¡®ä¿ç‚¹åœ¨æ ¼å­ä¸­é—´ä¹Ÿèƒ½å¸é™„åˆ°çº¿ä¸Š
            const x = Math.round((clickX - PADDING) / CELL_SIZE);
            const y = Math.round((clickY - PADDING) / CELL_SIZE);

            // è¾¹ç•Œæ£€æŸ¥ & æ˜¯å¦å·²æœ‰å­
            if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && board[y][x] === 0) {
                // è½å­
                board[y][x] = currentPlayer;
                history.push({ x, y, role: currentPlayer });

                drawBoard(); // é‡ç»˜

                // æ£€æŸ¥èƒœè´Ÿ
                if (checkWin(x, y, currentPlayer)) {
                    isGameOver = true;
                    // å»¶æ—¶ä¸€ç‚¹å¼¹å‡ºï¼Œä¸ºäº†è®©æ£‹å­å…ˆç”»å‡ºæ¥
                    setTimeout(() => {
                        alert((currentPlayer === 1 ? "é»‘æ–¹" : "ç™½æ–¹") + " è·èƒœï¼ğŸ‰");
                    }, 10);
                } else {
                    // åˆ‡æ¢å›åˆ
                    currentPlayer = currentPlayer === 1 ? 2 : 1;
                    updateUI();
                }
            }
        });

        // 4. èƒœè´Ÿåˆ¤æ–­ç®—æ³• (æ ¸å¿ƒ)
        function checkWin(x, y, role) {
            // å››ä¸ªæ–¹å‘ï¼šæ¨ªã€ç«–ã€å·¦æ–œã€å³æ–œ
            const directions = [
                [1, 0], [0, 1], [1, 1], [1, -1]
            ];

            for (let dir of directions) {
                let count = 1; // è‡ªå·±ç®—ä¸€ä¸ª

                // å‘ä¸€ä¸ªæ–¹å‘æ‰¾
                for (let i = 1; i < 5; i++) {
                    const nx = x + dir[0] * i;
                    const ny = y + dir[1] * i;
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && board[ny][nx] === role) {
                        count++;
                    } else {
                        break;
                    }
                }

                // å‘ç›¸åæ–¹å‘æ‰¾
                for (let i = 1; i < 5; i++) {
                    const nx = x - dir[0] * i;
                    const ny = y - dir[1] * i;
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && board[ny][nx] === role) {
                        count++;
                    } else {
                        break;
                    }
                }

                if (count >= 5) return true;
            }
            return false;
        }

        // 5. æ‚”æ£‹é€»è¾‘
        function undo() {
            if (isGameOver) {
                alert("æ¸¸æˆå·²ç»“æŸï¼Œè¯·ç‚¹å‡»é‡æ¥");
                return;
            }
            if (history.length === 0) return;

            // ç§»é™¤æœ€åä¸€æ­¥
            const lastMove = history.pop();
            board[lastMove.y][lastMove.x] = 0;

            // åˆ‡æ¢å›ä¸Šä¸€æ‰‹
            currentPlayer = lastMove.role;

            updateUI();
            drawBoard();
        }

        function restart() {
            if (confirm("ç¡®å®šè¦é‡æ–°å¼€å§‹å—ï¼Ÿ")) {
                init();
            }
        }

        function updateUI() {
            if (currentPlayer === 1) {
                turnIcon.className = "stone-icon black-stone";
                playerText.innerText = "é»‘æ–¹è½å­";
            } else {
                turnIcon.className = "stone-icon white-stone";
                playerText.innerText = "ç™½æ–¹è½å­";
            }
        }

        // å¯åŠ¨
        init();

    </script>
</body>

</html>